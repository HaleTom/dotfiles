#!/bin/bash
# ^ For shellcheck's happiness

# An assortment of useful bash functions. zsh sources this with 'emulate bash'.
# This file is expected to be sourced, not run.

function sh_is_zsh { [[ -n $ZSH_VERSION ]]; }
function sh_is_bash { [[ -n $BASH_VERSION ]]; }

# Allow functions to be accessed from bash sub-shells by:
# 'export_function <func-name>'
function export_function {
  # shellcheck disable=SC2163
  if sh_is_bash; then export -f "$@"; fi
  # zsh can't export functions: https://stackoverflow.com/a/1896039/5353461
}
export_function sh_is_bash sh_is_zsh

#
######### Start non-exported functions ##########
#
# These are to be run interactively, not by scripts

# less - highlight occurences of first argument
lessh() { e="$1"; shift; less -i -p "*$e" "$@"; }

# grep - highlight occurences of expression
greph() { e="$1"; shift; grep --col=always -Eih "$e|$" "$@"; }

# Print the hex and decimal value of the first character given
ord() { printf '%x\n' "'$1"; }
ord10() { printf '%d\n' "'$1"; }

# diff-so-fancy
dsf() { git diff --no-index --color "$@" | diff-so-fancy; }

##
######### End non-exported functions ##########
##

# Say the file, line number and optional message for debugging
# Inspired by bash's `caller` builtin
# Thanks to https://unix.stackexchange.com/a/453153/143394
# shellcheck disable=2120  # Use of global $*
function yelp () {
  # shellcheck disable=SC2154  # undeclared zsh variables in bash
  if [[ $BASH_VERSION ]]; then
    local file=${BASH_SOURCE[1]} func=${FUNCNAME[1]} line=${BASH_LINENO[0]}
  else  # zsh
    emulate -LR zsh  # Ensure 1-numbered arrays
    # $funcfiletrace has format:  file:line
    local file=${funcfiletrace[1]%:*} line=${funcfiletrace[1]##*:}
    local func=${funcstack[2]}
    [[ $func =~ / ]] && func=source  # $func may be filename. Use bash behaviour
  fi
  local quoter
  # Use shell-quote if it exists (nicer output in bash)
  if ! quoter=$(command -v shell-quote); then
    quoter=token_quote  # use function from this file
  fi
  echo "${file##*/}:$func:$line $("$quoter" "$@")" >&2
}
export_function yelp


# Return the first pathname in $PATH for name in $1
function bin_path () {
  if sh_is_zsh; then
    builtin whence -cp "$1" 2> /dev/null
  else  # bash
     builtin type -P "$1"  # No output if not in $PATH
  fi
}


function ostype () {
  case "$OSTYPE" in
    solaris*) echo "SOLARIS" ;;
    darwin*)  echo "OSX" ;;
    linux*)   echo "LINUX" ;;
    bsd*)     echo "BSD" ;;
    msys*)    echo "WINDOWS" ;;
    *)        echo "unknown: $OSTYPE" ;;
  esac
}


# Execute statements in $@ if $DEBUG is set
function debug () {
  [[ ! $DEBUG ]] && return
  [[ $BASH_VERSION ]] && eval "${@@Q}"
  # shellcheck disable=2154  # zsh syntax:
  [[ $ZSH_VERSION ]] && eval "${(q)@}"
}
export_function debug


# Expand an alias as text - https://unix.stackexchange.com/q/463327/143394
function alias_expand {
  if [[ $ZSH_VERSION ]]; then
    # shellcheck disable=2154  # aliases referenced but not assigned
    printf '%s\n' "${aliases[$1]}"
  else  # bash
    printf '%s\n' "${BASH_ALIASES[$1]}"
  fi
}


# Expand the variable named by $1 into its value. Works in both {ba,z}sh
function var_expand {
  [[ -n ${1+x} ]] && return 1
  eval printf '%s' "\"\${$1}\""
}


# Quote the contents of "$@"
# Avoid printf '%q' as  'a b'  becomes  a\ b  in both {ba,z}sh
# See also quote_args and double_quote
function token_quote {
  #Try built-in shell quoting first
  if sh_is_zsh; then
    # Single quotes only added when needed
    # http://zsh.sourceforge.net/Doc/Release/Expansion.html#Parameter-Expansion-Flags
    #shellcheck disable=2154  # zsh
    eval echo '"${(q-)@}"' 2> /dev/null || local printf_quote=1
  else  # bash
    # Single quotes are always added
    # ${parameter@operator} where parameter is ${@} and operator is 'Q'
    # https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html
    eval echo '"${@@Q}"' || local printf_quote=1
  fi

  # Older versions of {ba,z}sh don't support the syntax above, so fall back to printf %q
  if [[ -n $printf_quote ]]; then
    local quoted=()
    for token; do
      quoted+=( "$(printf '%q' "$token")" )
    done
    printf '%s\n' "${quoted[*]}"
  fi
}


# Join the elements of $2... with $1 as a delimiter
# https://stackoverflow.com/a/17841619
function array_join {
  local delim=$1; shift
  echo -n "$1"; shift
  printf "%s" "${@/#/$delim}"
}


# Echo literally what follows, including ';', '#', etc.
# https://unix.stackexchange.com/q/456508/143394
echo_literally_helper() {
  local str
  if [[ $BASH_VERSION ]]; then
    str=$(history 1)
    echo "${str#[\ ]*[0-9]*\ \ echo-literally\ }"  # rm leading space, number, alias
  else  # zsh
    # shellcheck disable=2154  # history variable not assigned
    str=${history[$(print -P %h)]}
    echo "${str#*echo_literally\ }"
  fi
}
alias echo_literally='echo_literally_helper #'


# Run the command given by "$@" in the background
silent_background() {
  if [[ -n $ZSH_VERSION ]]; then  # zsh:  https://superuser.com/a/1285272/365890
    setopt local_options no_notify no_monitor
    # We'd use &| to background and disown, but incompatible with bash, so:
    "$@" &
  elif [[ -n $BASH_VERSION ]]; then  # bash: https://stackoverflow.com/a/27340076/5353461
    { 2>&3 "$@"& } 3>&2 2>/dev/null
  else  # Unknownness - just background it
    "$@" &
  fi
  disown &>/dev/null  # /dev/null to prevent whine if job has already completed
}
export_function silent_background


# Change directory to the deepest existant part of a path
function cdup {
  # Eg:
  # $ mkdir -p a/b/c
  # $ cdup a/b/c/d/e
  # $ pwd
  # ~/a/b/c

  [[ $# -ne 1  ]] && { echo "${FUNCNAME[0]}: Must specify one directory" 2>&1; return 1; }
  try="$1"

  until [[ $try == . ]]; do
      if [[ -d $try && -x $try ]]; then
          cd "$try" && return $?
      fi
      try=$(dirname "$try")
  done
  return 1 # Couldn't cd to any part of the path
}
export_function cdup


function nbin {
  local dir;
  dir=$(npm bin)
  if [ -d "$dir" ]; then
    (  # subshell to not change this shell's $PATH   #' Grr, vim syntax-highlight
      PATH=$dir:$PATH
      eval $(token_quote "$@")
    )
  else
    echo "\"$dir\" is not an npm binary directory." >&1
    return 1
  fi
}


function man {
  local vman=${XDG_DATA_HOME-$HOME/.local/share}/vim/bundle/vim-superman/bin/vman
  # shellcheck disable=2034
  local EDITOR=vim  # https://github.com/jez/vim-superman/issues/19
  if [[ -t 1 && -x $vman ]]; then
    # STDOUT is a tty, $vman is executable
    for arg; do # Loop over "$@"
      case "$arg" in
        --) break;; # end of options
        -[sS]*|--section=*) continue ;; #These work with vim's :Man
        -*) vman=$(command -v man) # unknown option. Use usual man instead.
      esac
    done
    "$vman" "$@"
  else
    echo command man "$@"
  fi
}

######### End non-exported functions ##########

# True if argument is a function. Works in zsh and bash
# https://unix.stackexchange.com/a/332047/143394
is_function() {
    typeset -f "$1" > /dev/null
}
export_function is_function


# Read a single char from /dev/tty, prompting with "$*"
# Note: pressing enter will return a null string. Perhaps a version terminated with X and then remove it in caller?
# See https://unix.stackexchange.com/a/367880/143394 for dealing with multi-byte, etc.
function get_keypress {
  local REPLY IFS=
  >/dev/tty printf '%s' "$*"

  [[ $ZSH_VERSION ]] && read -rk1  # Use -u0 to read from STDIN
  # See https://unix.stackexchange.com/q/383197/143394 regarding '\n' -> ''
  [[ $BASH_VERSION ]] && </dev/tty read -rn1
  printf '%s' "$REPLY"
}
export_function get_keypress


# Prompt for a keypress to continue. Customise prompt with $*
function pause {
  >/dev/tty printf '%s' "${*:-Press any key to continue... }"
  [[ $ZSH_VERSION ]] && read -krs  # Use -u0 to read from STDIN
  [[ $BASH_VERSION ]] && </dev/tty read -rsn1
  printf '\n'
}
export_function pause


# Make a directory and move the working directory
function mkcd {
  if [ "$#" -ne 1 ]; then
    echo "${FUNCNAME[0]}: Make and change into a directory" >&2
    echo "Usage: ${FUNCNAME[0]} DIRECTORY" >&2
    return 69
  fi

  [[ -d "$1" ]] && exit=2 && echo "${FUNCNAME[0]}: Warning: $1 already exists." >&2
  mkdir -p "$1" || return 1
  cd "$1" || return 1
  return ${exit:-0}
}
export_function mkcd


#------ function make_completion_wrapper

# Updating? Start here: http://superuser.com/a/437508/365890 for one included into bash-it.

# The below is based on an earlier version at: https://ubuntuforums.org/showthread.php?t=733397
# See also: (my answer) http://unix.stackexchange.com/questions/4219/how-do-i-get-bash-completion-for-command-aliases/4220#4220

# Wraps a completion function, eg for use with an alias.
# Usage:
# make-completion-wrapper <actual completion function> <name of new func.>
#                         <command name> <list supplied arguments>
# eg.
#   alias agi='apt-get install'
#   make-completion-wrapper _apt_get _apt_get_install apt-get install
#     # defines a function called _apt_get_install (that's $2) that will
#     # complete the 'agi' alias. 
#   complete -F _apt_get_install agi
function make_completion_wrapper {
  local function_name="$2"
  local arg_count=$(( $#-3 ))
  local comp_function_name="$1"
  shift 2
  local funktion="function $function_name {
  (( COMP_CWORD += $arg_count ))
  COMP_WORDS=( \"\$@\" \${COMP_WORDS[@]:1} )
  \"$comp_function_name\"
}"
eval "$funktion"
# echo "$funktion"
}
export_function make_completion_wrapper


# Print the absolute path of the containing directory
function abs_dirname {
  if [[ $# = 0 ]]; then set .; fi # current directory if no arguments
  for path in "$@"; do 
    (cd "${dir:="$(dirname "$path")"}" && pwd || exit 1 )
    [[ ! $? ]] && return 1
  done
}
export_function abs_dirname


# Wrapper for systems that don't support `readlink -f`
function abs_path {
  for _ in $(eval echo "{1..$#}"); do
    # Warning: Doesn't work when called with '..'
    # echo $(cd $(dirname "$1") && pwd -P)/$(basename "$1")
    # path=$(cd $(dirname "$1" || return 1) && pwd -P) &&
    #   path="$path"/$(basename "$1")
    # [[ $? -ne 0 ]] && return 1
    # echo "$path"
    readlink -f "$1" || return 1
    shift
  done
}
export_function abs_path


# The name of the git directory (usually '.git') of the current repository
function git_dir {
  # $_ is currently overwitten by chruby_auto
  local dir
  dir=$(git rev-parse --git-dir) || return 1
  abs_path "$dir"
}
export_function git_dir


# TL;DR: Just use printf "%q\n" "$@"
# Escape arguments for use in eval. From
# http://stackoverflow.com/questions/12162010/posix-sh-equivalent-for-bash-s-printf-q

# Usage examples at: http://search.cpan.org/~rosch/String-ShellQuote-1.03/shell-quote
function quote_args {
  case $# in 0) return 0; esac
  while :; do
    printf "'"
    printf %s "$1" | sed "s/'/'\\\\''/g"
    shift
    case $# in 0) break; esac
    printf "' "
  done
  printf "'\\n"
}
export_function quote_args


function double_quote {
  case $# in 0) return 0; esac
  while :; do
    printf '"'
    printf %s "$1" | sed 's/\([$`\!"]\)/\\\1/g'
    shift
    case $# in 0) break; esac
    printf '" '
  done
  printf '"\n'
}
export_function double_quote


# Get a y/n from the user, return yes=0, no=1 enter=$2
# Prompt using $1.
# If set, return $2 on pressing enter, useful for cancel or defualting
function get_yes_keypress {
  local prompt="${1:-Are you sure [y/n]? }"
  local enter_return=$2
  local REPLY
  while REPLY=$(get_keypress "$prompt"); do
    [[ $REPLY ]] && printf '\n' # $REPLY blank if user presses enter
    case "$REPLY" in
      Y|y)  return 0;;
      N|n)  return 1;;
      '')   [[ $enter_return ]] && return "$enter_return"
    esac
  done
}
export_function get_yes_keypress


# Prompt to confirm, defaulting to NO on <enter>
# Usage: confirm "Dangerous. Are you sure?" && rm *
# For a shorter non-single-key version
# http://unix.stackexchange.com/a/14444/143394
function confirm {
  local prompt="${*:-Are you sure} [y/N]? "
  get_yes_keypress "$prompt" 1
}
export_function confirm


# Prompt to confirm, defaulting to YES on <enter>
function confirm_yes {
  local prompt="${*:-Are you sure} [Y/n]? "
  get_yes_keypress "$prompt" 0
}
export_function confirm_yes


# Print the name of the git repository's working tree's root directory
# Search for 'Tom Hale' in http://stackoverflow.com/questions/957928/is-there-a-way-to-get-the-git-root-directory-in-one-command
# Or, shorter: 
# (root=$(git rev-parse --git-dir)/ && cd ${root%%/.git/*} && git rev-parse && pwd)
# but this doesn't cover external $GIT_DIRs which are named other than .git
function git_root {
  local root first_commit
  # git displays its own error if not in a repository
  root=$(git rev-parse --show-toplevel) || return
  if [[ -n $root ]]; then
    echo "$root"
    return
  elif [[ $(git rev-parse --is-inside-git-dir) = true ]]; then
    # We're inside the .git directory
    # Store the commit id of the first commit to compare later
    # It's possible that $GIT_DIR points somewhere not inside the repo
    first_commit=$(git rev-list --parents HEAD | tail -1) || # --reverse with head -1?
      echo "${FUNCNAME[0]}: Can't get initial commit" 2>&1 && false && return
    root=$(git rev-parse --git-dir)/.. &&
      # subshell so we don't change the user's working directory
    ( cd "$root" &&
      if [[ $(git rev-list --parents HEAD | tail -1) = "$first_commit" ]]; then
        pwd
      else
        echo "${FUNCNAME[0]}: git directory is not inside its repository" 2>&1
        false
      fi
    )
  else
    echo "${FUNCNAME[0]}: Can't determine repository root" 2>&1
    false
  fi
}
export_function git_root


# Change working directory to git repository root
function cd_git_root {
  local root
  root=$(git_root) || return # git_root will print any errors
  cd "$root" || return
}
export_function cd_git_root


# apt: Update only given sources 
function apt_update_repo() {
  for source in "$@"; do
    sudo apt-get update -o Dir::Etc::sourcelist="sources.list.d/${source}" \
    -o Dir::Etc::sourceparts="-" -o APT::Get::List-Cleanup="0"    
  done
}
export_function apt_update_repo


ansi_colours() {
        local fgc bgc vals seq0

        # shellcheck disable=SC2016
        printf 'Color escapes are %s\n' '\e[${value};...;${value}m'
        printf 'Values 30..37 are \e[33mforeground colors\e[m\n'
        printf 'Values 40..47 are \e[43mbackground colors\e[m\n'
        printf 'Value  1 gives a  \e[1mbold-faced look\e[m\n'
        printf '%s\n\n' 'printf "\e[m" resets'

        # foreground colors
        for fgc in $(seq 30 37); do
                # background colors
                for bgc in $(seq 40 47); do
                        fgc=${fgc#37} # white
                        bgc=${bgc#40} # black

                        vals="${fgc:+$fgc;}${bgc}"
                        vals=${vals%%;}

                        seq0="${vals:+\e[${vals}m}"
                        printf "  %-9s" "${seq0:-(default)}"
                        printf " ${seq0}TEXT\\e[m"
                        printf ' \e[%s1mBOLD\e[m' "${vals:+${vals+$vals;}}"
                done
                echo; echo
        done
}
export_function ansi_colours
