#!/bin/bash
# ^ For shellcheck's happiness

# An assortment of useful {z,ba}sh functions
# This file is expected to be sourced, not run.

function sh_is_zsh { [[ -n $ZSH_VERSION ]]; }
function sh_is_bash { [[ -n $BASH_VERSION ]]; }

# Allow functions to be accessed from bash sub-shells by:
# 'export_function <func-name>'
function export_function {
  # shellcheck disable=SC2163
  sh_is_bash && export -f "$@"
  # zsh can't export functions: https://stackoverflow.com/a/1896039/5353461
}
export_function sh_is_bash sh_is_zsh

#
######### Start non-exported functions ##########
#
# These are to be run interactively, not by scripts

# less - highlight occurences of first argument
lessh() { e="$1"; shift; less -i -p "*$e" "$@"; }

# grep - highlight occurences of expression
greph() { e="$1"; shift; grep --col=always -Eih "$e|$" "$@"; }

# Print the hex and decimal value of the first character given
ord() { printf '%x\n' "'$1"; }
ord10() { printf '%d\n' "'$1"; }

# diff-so-fancy
dsf() { git diff --no-index --color "$@" | diff-so-fancy; }

#
######### End non-exported functions ##########
#

# Run the command given by "$@" in the background
silent_background() {
  if [[ -n $ZSH_VERSION ]]; then  # zsh:  https://superuser.com/a/1285272/365890
    setopt local_options no_notify no_monitor
    # We'd use &| to background and disown, but incompatible with bash, so:
    "$@" &
  elif [[ -n $BASH_VERSION ]]; then  # bash: https://stackoverflow.com/a/27340076/5353461
    { 2>&3 "$@"& } 3>&2 2>-
  else  # Unknownness - just background it
    "$@" &
  fi
  disown &>-  # Close STD{OUT,ERR} to prevent whine if job has already completed
}
export_function silent_background


# Change directory to the deepest existant part of a path
function cdup {
  # Eg:
  # $ mkdir -p a/b/c
  # $ cdup a/b/c/d/e
  # $ pwd
  # ~/a/b/c

  [[ $# -ne 1  ]] && { echo "${FUNCNAME[0]}: Must specify one directory" 2>&1; return 1; }
  try="$1"

  until [[ $try == . ]]; do
      if [[ -d $try && -x $try ]]; then
          cd "$try" && return $?
      fi
      try=$(dirname "$try")
  done
  return 1 # Couldn't cd to any part of the path
}
export_function cdup


function nbin {
  local dir;
  dir=$(npm bin)
  if [ -d "$dir" ]; then
    ( # subshell to not change this shell's $PATH
      PATH=$dir:$PATH
      eval "$@"
    )
  else
    echo "\"$dir\" is not an npm binary directory." >&1
    return 1
  fi
}

function man {
  local vman="$XDG_DATA_HOME/vim/bundle/vim-superman/bin/vman"
  if [[ -t 1 && -x $vman ]]; then
    # STDOUT is a tty, $vman is executable
    for arg; do # Loop over "$@"
      case "$arg" in
        --) break;; # end of options
        -[sS]*|--section=*) continue ;; #These work with vim's :Man
        -*) vman="$(which man)" # unknown option. Use usual man instead.
      esac
    done
    "$vman" "$@"
  else
    echo command man "$@"
  fi
}

######### End non-exported functions ##########

# True if argument is a function. Works in zsh and bash
# https://unix.stackexchange.com/a/332047/143394
is_function() {
    typeset -f "$1" > /dev/null
}
export_function is_function

function pause {
  read -n1 -rsp "Press any key to continue... " _
  printf "\n"
}
export_function pause

# Make a directory and move the working directory
function mkcd {
  if [ "$#" -ne 1 ]; then
    echo "${FUNCNAME[0]}: Make and change into a directory" >&2
    echo "Usage: ${FUNCNAME[0]} DIRECTORY" >&2
    return 69
  fi

  [[ -d "$1" ]] && exit=2 && echo "${FUNCNAME[0]}: Warning: $1 already exists." >&2
  mkdir -p "$1" || return 1
  cd "$1" || return 1
  return ${exit:-0}
}
export_function mkcd


#------ function make_completion_wrapper

# Updating? Start here: http://superuser.com/a/437508/365890 for one included into bash-it.

# The below is based on an earlier version at: https://ubuntuforums.org/showthread.php?t=733397
# See also: (my answer) http://unix.stackexchange.com/questions/4219/how-do-i-get-bash-completion-for-command-aliases/4220#4220

# Wraps a completion function, eg for use with an alias.
# Usage:
# make-completion-wrapper <actual completion function> <name of new func.>
#                         <command name> <list supplied arguments>
# eg.
#   alias agi='apt-get install'
#   make-completion-wrapper _apt_get _apt_get_install apt-get install
#     # defines a function called _apt_get_install (that's $2) that will
#     # complete the 'agi' alias. 
#   complete -F _apt_get_install agi
function make_completion_wrapper {
  local function_name="$2"
  local arg_count=$(( $#-3 ))
  local comp_function_name="$1"
  shift 2
  local funktion="function $function_name {
  (( COMP_CWORD += $arg_count ))
  COMP_WORDS=( \"\$@\" \${COMP_WORDS[@]:1} )
  \"$comp_function_name\"
}"
eval "$funktion"
# echo "$funktion"
}
export_function make_completion_wrapper


# Print the absolute path of the containing directory
function abs_dirname {
  if [[ $# = 0 ]]; then set .; fi # current directory if no arguments
  for path in "$@"; do 
    (cd "${dir:="$(dirname "$path")"}" && pwd || exit 1 )
    [[ ! $? ]] && return 1
  done
}
export_function abs_dirname


# Wrapper for systems that don't support `readlink -f`
function abs_path {
  for _ in $(eval echo "{1..$#}"); do
    # Warning: Doesn't work when called with '..'
    # echo $(cd $(dirname "$1") && pwd -P)/$(basename "$1")
    # path=$(cd $(dirname "$1" || return 1) && pwd -P) &&
    #   path="$path"/$(basename "$1")
    # [[ $? -ne 0 ]] && return 1
    # echo "$path"
    readlink -f "$1" || return 1
    shift
  done
}
export_function abs_path


# The name of the git directory (usually '.git') of the current repository
function git_dir {
  # $_ is currently overwitten by chruby_auto
  local dir
  dir=$(git rev-parse --git-dir) || return 1
  abs_path "$dir"
}
export_function git_dir


# TL;DR: Just use printf "%q\n" "$@"
# Escape arguments for use in eval. From
# http://stackoverflow.com/questions/12162010/posix-sh-equivalent-for-bash-s-printf-q

# Usage examples at: http://search.cpan.org/~rosch/String-ShellQuote-1.03/shell-quote
function quote_args {
  case $# in 0) return 0; esac
  while :; do
    printf "'"
    printf %s "$1" | sed "s/'/'\\\\''/g"
    shift
    case $# in 0) break; esac
    printf "' "
  done
  printf "'\n"
}
export_function quote_args


function double_quote {
  case $# in 0) return 0; esac
  while :; do
    printf '"'
    printf %s "$1" | sed 's/\([$`\!"]\)/\\\1/g'
    shift
    case $# in 0) break; esac
    printf '" '
  done
  printf "\"\n"
}
export_function double_quote


# http://unix.stackexchange.com/a/14444/143394
# Usage: confirm "Dangerous. Are you sure?" && rm /
function confirm {
  local reply
  while IFS= read -rn1 -p "${*:-Are you sure} [y/N]? " reply; do
    [ ! "$reply" = '' ] && printf "\n"
    case "$reply" in
      # See https://unix.stackexchange.com/q/383197/143394 regarding '\n' -> ''
      Y|y* )      return 0;;
      [Nn\ ]|'' ) return 1;;
    esac
  done
}
export_function confirm


function confirm_yes {
  local reply
  while IFS= read -rn1 -p "${*:-Are you sure} [Y/n]? " reply; do
    [ ! "$reply" = '' ] && printf "\n"
    case "$reply" in
      # See https://unix.stackexchange.com/q/383197/143394 regarding '\n' -> ''
      [Yy\ ]|'' ) return 0;;
      N|n )       return 1;;
    esac
  done
}
export_function confirm_yes


# Print the name of the git repository's working tree's root directory
# Search for 'Tom Hale' in http://stackoverflow.com/questions/957928/is-there-a-way-to-get-the-git-root-directory-in-one-command
# Or, shorter: 
# (root=$(git rev-parse --git-dir)/ && cd ${root%%/.git/*} && git rev-parse && pwd)
# but this doesn't cover external $GIT_DIRs which are named other than .git
function git_root {
  local root first_commit
  # git displays its own error if not in a repository
  root=$(git rev-parse --show-toplevel) || return
  if [[ -n $root ]]; then
    echo "$root"
    return
  elif [[ $(git rev-parse --is-inside-git-dir) = true ]]; then
    # We're inside the .git directory
    # Store the commit id of the first commit to compare later
    # It's possible that $GIT_DIR points somewhere not inside the repo
    first_commit=$(git rev-list --parents HEAD | tail -1) || # --reverse with head -1?
      echo "${FUNCNAME[0]}: Can't get initial commit" 2>&1 && false && return
    root=$(git rev-parse --git-dir)/.. &&
      # subshell so we don't change the user's working directory
    ( cd "$root" &&
      if [[ $(git rev-list --parents HEAD | tail -1) = "$first_commit" ]]; then
        pwd
      else
        echo "${FUNCNAME[0]}: git directory is not inside its repository" 2>&1
        false
      fi
    )
  else
    echo "${FUNCNAME[0]}: Can't determine repository root" 2>&1
    false
  fi
}
export_function git_root


# Change working directory to git repository root
function cd_git_root {
  local root
  root=$(git_root) || return # git_root will print any errors
  cd "$root" || return
}
export_function cd_git_root


# apt: Update only given sources 
function apt_update_repo() {
  for source in "$@"; do
    sudo apt-get update -o Dir::Etc::sourcelist="sources.list.d/${source}" \
    -o Dir::Etc::sourceparts="-" -o APT::Get::List-Cleanup="0"    
  done
}
export_function apt_update_repo


ansi_colours() {
        local fgc bgc vals seq0

        # shellcheck disable=SC2016
        printf "Color escapes are %s\n" '\e[${value};...;${value}m'
        printf "Values 30..37 are \e[33mforeground colors\e[m\n"
        printf "Values 40..47 are \e[43mbackground colors\e[m\n"
        printf "Value  1 gives a  \e[1mbold-faced look\e[m\n"
        printf '%s\n\n' 'printf "\e[m" resets'

        # foreground colors
        for fgc in {30..37}; do
                # background colors
                for bgc in {40..47}; do
                        fgc=${fgc#37} # white
                        bgc=${bgc#40} # black

                        vals="${fgc:+$fgc;}${bgc}"
                        vals=${vals%%;}

                        seq0="${vals:+\e[${vals}m}"
                        printf "  %-9s" "${seq0:-(default)}"
                        printf " %sTEXT\e[m" "$seq0"
                        printf " \e[%s1mBOLD\e[m" "${vals:+${vals+$vals;}}"
                done
                echo; echo
        done
}
export_function ansi_colours
