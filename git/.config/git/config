[include]
  # Put personal details (eg name, email) in another file
  # This file is excluded by .gitignore
  path = ./config-ravi

[core]
  # editor = nvim  # Order: $GIT_EDITOR, core.editor, $VISUAL, $EDITOR, compile-time default (vi)
  # pager order: $GIT_PAGER, core.pager, $PAGER, compile-time default (less)
  pager = "command -v pager &>/dev/null && pager || less -FLRX --tabs=4"
  excludesFile = ~/.config/git/ignore

[mailmap]
  file = ~/.config/git/mailmap


  # convert newlines to system's standard on checkout,
  # and to LF when checking in
  # Eeek - causes addition of CR in linux
  # autocrlf = true

# Alias syntax learnings:
# Double quotes around shell commands are not required
# If you want to \ continue a line, it must be inside a "-quoted string
# Continue/wrap long lines with final \ character
# It's not possible to have a comment after a continuation \
# Quote ALL newline, " and \ characters as \n, \" and \\
# A literal '#' or ';' must be inside "-quotes
; this is also a comment

# Gotchas:
# rev-parse without --verify prints its argument, then returns false

[alias]  # these are case INsensitive
  a      = add
  aa     = add -A  # deletions and new files
  ar     = "!git add \"$(rev-parse --show-toplevel)\" \"$@\" #"  # Repo level: New and changed, no deletions
  av     = add -v
  ax     = git add .  # Current directory: New and changed, no deletions
  aacm   = "!f() { git add -A && git commit -m \"$@\"; }; f"
  an     = add --intent-to-add # add -N
  ap     = !"VISUAL=\"VISUAL='$VISUAL' bash -c 'set -m; less -K -+F \\\"\\$1\\\"' --\" git add --patch \"$@\" #"  # https://stackoverflow.com/a/63688649/5353461
  au     = add --update  # deletions of tracked files but no new ones
  aucnn  = !"git au && git cnn #"
  aut    = "!git ls-files -z -o --exclude-standard | xargs -0 git add; #" # Add only untracked files
  aw     = !git diff -U0 -w --no-color -- \"$@\" | git apply --cached --ignore-whitespace --unidiff-zero "#" # Add only non-whitespace changes
  aow    = !git add -- \"$@\" && git diff --cached -w | git apply --cached -R "#" # Add only whitespace changes
  bi     = bisect
  bis    = bisect start
  bib    = bisect bad
  big    = bisect good
  bir    = bisect reset
  br     = branch
  brd    = branch -d
  brdd   = branch -D # Same as branch --force. Allow deletion if branch is not merged.
  brf    = branch -f
  brl    = branch --list
  brm    = branch --move # rename
  brt    = branch --track
  bru    = branch --set-upstream-to  # branch -u is equivalent
  c      = commit
  # Pick chunks to include of changed files, include all untracked files.
  ca     = commit -a -v
  caa    = "!f() { git add -A && git commit \"$@\"; }; f"
  caam   = "!f() { git add -A && git commit --message \"$@\"; }; f"
  caan   = "!f() { git add -A && git commit --amend "\"$@\"; }; f"
  caanm   = "!f() { git add -A && git commit --amend -m "\"$@\"; }; f"
  caann  = "!f() { git add -A && git commit --amend --no-edit; }; f"
  cam    = commit -am  # note only changed files included
  can    = commit -a --amend
  cann   = commit -a --amend --no-edit
  canm   = commit -a --amend -m
  cfu    = !"bash -c 'git commit --fixup=\"$1\" \"${@:2}\"' _ \"$@\" #"
  ch     = cherry-pick
  cha    = cherry-pick --abort
  chc    = cherry-pick --continue
  cinit  = !"git init; git is-empty-repo && git commit --allow-empty -m 'Initialise repository'" # init on existing repo is safe
  cl     = clone
  # clone --depth flag implies --single-branch
  # To deepen: git fetch --deepen 50
  # More: https://stackoverflow.com/questions/6802145/how-to-convert-a-git-shallow-clone-to-a-full-clone
  cls    = clone --depth 20 --shallow-submodules --recurse-submodules
  clsa    = clone --depth 5 --shallow-submodules --recurse-submodules -â€“no-single-branch  # Clone all branches
  clsb   = clone --depth 20 --shallow-submodules --recurse-submodules --branch  # eg git clsb maint git://github.com/user/repo"
  clrsm  = clone --recurse-submodules
  # Note git clean operates from the current directory, same behaviour:
  clear  = !"cd ${GIT_PREFIX:-.} && bash -c 'git clean -nd \"$@\" | sed \"s/^Would remove //\"; \
    read -rn1 -p \"Delete all the above? [y/N] \" r; echo; \
    [[ x$r =~ ^x[yY] ]] && git clean -df \"$@\" || echo Untouched.' removed \"$@\" #"
  # Same as above, but relative to root directory
  clearr  = !"bash -c 'git clean -nd \"$@\" | sed \"s/^Would remove //\"; \
    read -rn1 -p \"Delete all the above? [y/N] \" r; echo; \
    [[ x$r =~ ^x[yY] ]] && git clean -df \"$@\" || echo Untouched.' removed \"$@\" #"
  cm     = commit -m
  # Default commit mode if files are given is --only, which only commits the named paths.
  # https://stackoverflow.com/a/51587932/5353461
  # The alternative to --only is --include.  --only = intersect,  --include = union.
  cmaf = !"git cmf \"Add $*\" \"$@\" # Add files with comment like: Add f1 f2 f3"
  cmf    = !"bash -c '[ $# -ge 2 ] || { echo \"Give arguments: <commit msg> <files>\" >&2; exit 1; }; cd ${GIT_PREFIX:-.} && git add \"${@:2}\" && git commit -m \"$@\"' _ \"$@\" #"
  cmi    = !"bash -c '[ $# -ge 2 ] || { echo \"Give arguments: <commit msg> <files>\" >&2; exit 1; }; cd ${GIT_PREFIX:-.} && git commit -m \"${@:1:1}\" -i \"${@:2}\"' - \"$@\" # Include named files in index, then commit"
  cmu    = "! cd \"${GIT_PREFIX:-.}\" && git add --update \"${@:2}\" && git commit -m \"$@\" # Update add, then commit with message"
  au     = add --update  # deletions of tracked files but no new ones
  cn     = commit --amend
  # cn0    = commit --amend --allow-empty
  cne    = commit --no-edit
  cnn    = commit --amend --no-edit
  cnnra  = commit --amend --no-edit --reset-author
  cnrbc  = !"git cn  && git rbc #"
  cnnrbc = !"git cnn && git rbc #"
  cnm    = commit --amend -m
  co     = checkout
  co-    = !"git checkout @{-1}; git print-commit-1 @ #"
  cob    = checkout -b
  cobb   = checkout -B
  cof    = checkout --force
  # Create a branch tracking the same branch on origin.
  # '-' makes argument list start at $1
  cobt   = !sh -c 'git checkout -b "$1" && git branch --track origin/"$1"' -
  coo    = checkout --ours
  cop    = checkout --patch
  cos    = !"git spcosp \"$@\" # move uncommitted changes to new branch via stash"
  cot    = checkout --theirs
  cp     = commit --patch
  cvp    = "!f() { git commit -v --patch \"$@\"; git st; }; f"
  # Select hunks from tracked files, then commit with all untracked files before commit
  cvpn   = "!f() { git commit -v --patch && \
    git ls-files -z -o --exclude-standard | xargs -0 git add && \
    echo '# Add only new files silently' > /dev/null && \
    git commit -a --amend --no-edit && \
    git status -s; }; f"
  d      = diff
  dr     = diff -R
  db     = "!export GIT_TRACE=1; git" # Use to debug an alias, Eg: git db <aliasname>
  db-ssh = "!GIT_SSH_COMMAND='ssh -vvv' git"
  debug  = "!set -x; export GIT_TRACE=2 GIT_CURL_VERBOSE=2 GIT_TRACE_PERFORMANCE=2 GIT_TRACE_PACK_ACCESS=2 GIT_TRACE_PACKET=2 GIT_TRACE_PACKFILE=2 GIT_TRACE_SETUP=2 GIT_TRACE_SHALLOW=2 GIT_TRACE_EXCLUDE=1; git"
  dc     = diff --cached
  dcs    = diff --cached --compact-summary --dirstat
  dcp    = diff --cached HEAD~
  dcps   = diff --cached --compact-summary --dirstat HEAD~
  dn     = diff --no-index
  dp     = diff HEAD~
  dps    = diff --compact-summary --dirstat HEAD~
  ds     = diff --compact-summary --dirstat  # implies --stat
  dt     = difftool -y
  dxc    = "!case \"$1\" in -*|'') ;; *) x=$(git rpc \"${1:-HEAD}\");shift;esac; git d \"$@\" \"$x\" \"$(git child-hash \"$x\")\" #" # Diff given with its first child
  dxp    = "!case \"$1\" in -*|'') ;; *) x=$(git rpc \"${1:-HEAD}\") && shift; esac && git d \"${x:=HEAD}~\" \"$x\" \"$@\" # Diff given with its first parent, allow for files at end"
  ec     = !"git status -sz  | sed -rnz 's/^(U.|.U) (.*)/\\2/p' | xargs -0 $VISUAL #"
  elc    = !"git edit-config"
  egc    = !"git edit-global-config"  # ~/.gitconfig will be read after and override ~/.config/git/config
  egx    = !"git edit-global-excludes"
  elx    = !"git edit-local-excludes"
  f      = fetch
  ff     = merge --ff-only @{u}  # But try just 'git rebase' if HEAD is behind upstream
  fu     = fixup
  fum    = fetch upstream master:master
  fua    = fixup-auto
  g      = !"cd \"${GIT_PREFIX:-.}\" && git \"$@\" #"  # Idempotent. Allow for `gsudo !!` to run previous command as root.
  head   = !"c=$(git rpc \"$1\") && p=$(git log -n1 --oneline --decorate) && git update-ref --no-deref -m \"Move from $p\" HEAD \"$c\" #" # Move HEAD to specified commit-ish
  icdiff = difftool --no-prompt --extcmd icdiff # \"$@\"
  l      = log --compact-summary --dirstat
  la     = !"git config --list | grep '^alias\\.' | cut -c 7- | awk '!seen[$0]++' | grep -Ei --color -e \"$@\"  # List unsorted unique aliases. -e allows multiple patterns beginning with -"
  lao    = !"git config --list --show-origin | sed -n 's/\\t\\(alias.\\)/\\t/p' | grep -Ei --color -e \"$@\"  # List aliases, show config pathname"
  l1     = print-commit-1
  logd   = log --oneline --graph --decorate --remotes --max-count=20
  logd   = !"eval git log $(git fmt-commit-1line) --graph --remotes --max-count=20 #"
  logdi  = !"eval git log $(git fmt-commit-1line-iso) --graph --remotes --max-count=20 #"
  logda  = !"lines=$(($(tput lines)*3/5)); eval git log $(git fmt-commit-1line) --graph --all --remotes --color=always \"$@\" | head -n$lines #"
  logdai  = !"lines=$(($(tput lines)*3/5)); eval git log $(git fmt-commit-1line-iso) --graph --all --remotes --color=always \"$@\" | head -n$lines #"
  logdaa = !"eval git log $(git fmt-commit-1line) --graph --all --remotes --color=always \"$@\" #"
  logdaai= !"eval git log $(git fmt-commit-1line-iso) --graph --all --remotes --color=always \"$@\" #"
  lp     = log --patch --compact-summary --dirstat
  lsr    = ls-remote
  lsrt   = ls-remote --tags --refs
  ls     = ls-files
  ma     = merge --abort
  mc     = merge --continue
  mnf    = merge --no-ff
  mom    = merge origin/master
  mt     = mergetool -y
  mum    = merge upstream/master
  psf    = push --force-with-lease
  psuo   = push --set-upstream origin
  psurb  = "![ $# -ne 1 ] && { echo 'Give argument: <remote-for-upstream>' >&2; exit 1; }; b=\"$(git rev-parse --abbrev-ref HEAD)\" && git push --set-upstream \"${1?}\" \"$b\" #"
  psuob  = "!b=\"$(git rev-parse --abbrev-ref HEAD)\" && git push --set-upstream origin \"$b\" #"

# ff-only pull into another branch (must change branches for generic merge or pull)
# https://stackoverflow.com/a/17722977/5353461
#
# Check this works on current branch. May need to checkout HEAD:
# https://stackoverflow.com/questions/3216360/merge-update-and-pull-git-branches-without-using-checkouts
# git update-ref -m  # https://stackoverflow.com/a/3217376/5353461
# But use pull instead for current branch case.
  plff   = !"x=$(git rev-parse --symbolic-full-name \"${1:-master}\") && { [ $# -ge 1 ] && shift; :; } && eval git db fetch $(git for-each-ref --shell --format='%(upstream:remotename) %(upstream:lstrip=3):%(refname:short)' \"$x\") \"$@\" #"

  plws   = wrapstash git pull --no-autostash
  pl     = plws --progress
  plr    = plws --rebase
  plrf   = plws --rebase=false  # Merge
  plrm   = plws --rebase=merges  # Transplant the whole topology of commit graph elsewhere. https://stackoverflow.com/a/50555740/5353461
  # plrp   = plws --rebase=preserve  # Deprecated in favour of merges
  plri   = plws --rebase=interactive
  plrbm  = "!git plws && git rebase --autosquash --autostash \"${1:-master}\" \"${@:2}\" #"
  pp     = "!echo Pull:; git plws --rebase \"$@\" && echo Push: && git push #"
  ps     = push
  prq    = !"hub pull-request \"$@\" #"
  # XXX TODO merge thest into master branch not currently checked out branch
  # pom    = pl origin master
  # pum    = pl upstream master
  rb     = rebase
  rba    = rebase --abort
  rbb    = !"git rebase -i $(git merge-base $1 HEAD) #" # Rebase to branch-name # http://stackoverflow.com/a/31036518/5353461
  rbc    = rebase --continue
  rbce   = !"git commit -t \"$(git rev-parse --git-dir)\"/rebase-apply/final-commit && git rebase --skip # commit editing message"  # https://stackoverflow.com/a/30224412/5353461
  rbi    = !"bash -c 'c=${1:+$(git rpc \"$1\")~} && set -- ${@:2} && git rebase --interactive --autostash --autosquash --keep-empty \"$(git rpc \"${c:-$(git parent 20)}\")\" \"$@\"' - \"$@\" # Interactive rebase"
  rbia   = !"GIT_SEQUENCE_EDITOR=true git rbi \"$@\" #"
  rbm    = rebase master
  rbmg   = rebase --rebase-merges  # incompatible with interactive
  rbo    = rebase --onto
  rboq   = wrapstash git rboqws
  rboqws = !"bash -c 'x=$(git branch-or-commit HEAD) && git rbo \"$1\" \"${@:2:$# -2}\" \"$(git branch-name \"${@:$#}\")\" && git co \"$x\"' - \"$@\" # Rebase onto <dest> <pre-start> <last> then return to previous HEAD"
  rbox   = !"bash -c 'git branch-name ${@:$#} >/dev/null && git rbo HEAD \"$@\"' - \"$@\" # Requires branch else nothing happens??  # Takes args: [git-args] <pre-start> <end>"
  rboxq  = rboq HEAD  # Takes args: [git-args] <pre-start> <end>
  rbroot = rebase --root # Allows changing root commit(s)
  rbs    = rebase --skip
  ro     = remote
  roa    = remote add
  rog    = remote get-url
  rogp   = remote get-url --push
  rorm   = remote remove
  rorn   = remote rename
  ros    = remote set-url
  rosp   = remote set-url --push
  rou    = remote update
  rov    = remote --verbose
  re     = reset
  reco   = !"cd \"${GIT_PREFIX:-.}\" && git reset -- \"$@\" && git checkout -- \"$@\" # File version"  # Use the current commit
  recoc   = !"cd \"${GIT_PREFIX:-.}\" && git reset \"$@\" && git checkout \"$@\" # Commit version"  # https://stackoverflow.com/a/52313420/5353461
  reh    = reset --hard
  rem    = reset --merge # Like hard but don't reset files that haven't been committed, failing if the target commit has changes in those files
  rep    = reset --patch
  res    = reset --soft
  # XXX test with $(:) resc
  resc   = !"git reset --soft $(c=$(git child); [ \"$c\" ] && echo $c || git children)" # Move HEAD to the child
  resp   = reset --soft HEAD~ # Move HEAD to the first Ancestor
  rl     = reflog --pretty=reflog
  rp     = rev-parse --verify  # Without --verify, the argument is printed, then an error message
  rpc    = !"x=$(git rev-parse \"$1\") && git rev-parse --verify \"$x\"^{commit} # allow :/<regex> format"
  rpt    = !"x=$(git rev-parse \"$1\") && git rev-parse --verify \"$x\"^{tag}    # allow :/<regex> format"
  rr     = rerere
  rrd    = rerere diff
  rrf    = rerere forget
  rrr    = rerere remaining
  rrs    = rerere status
  rmc    = rm --cached
  # Status
  s      = !"cd \"${GIT_PREFIX:-.}\" && git print-commit-1 HEAD; git status --short" # allow for git s .
  si     = !"git print-commit-1 HEAD; git status --short --ignored"
  # Submodule
  sm     = submodule
  sma    = submodule add
  sms    = submodule status
  # Stash
  sa     = stash apply
  sai    = stash apply --index
  sb     = stash branch
  sc     = stash clear # all
  sd     = stash drop # latest or specified
  sl     = stash list
  sls    = stash list --compact-summary --dirstat
  slp    = stash list --patch --compact-summary --dirstat
  sp     = stash pop --index
  spni   = stash pop  # no index
  sps    = stash push
  spcosp = !"git stash push && git checkout \"$@\" && git stash pop #"
  spsp   = stash push --patch
  ss     = stash push
  ssa    = stash push --all # includes ignored
  ssk    = stash push --keep-index # Changes to index are left intact
  sskm   = stash push --keep-index --message
  ssm    = stash push --message
  ssp    = stash save --patch
  ssu    = stash save --include-untracked
  sska   = stash save --keep-index --all # includes ignored
  ssku   = stash save --keep-index --include-untracked
  sskua  = stash save --keep-index --include-untracked --all
  t      = tag
  tf     = tag -f
  tl     = "!git tag -n1 | sort -V"  # -n1 prints one line from annotation and implies --list
  tm     = tag -m
  td     = tag -d
  ws     = wrapstash

  # Ignored files, including those included by index
  # If avoiding passing context number of lines, then no colour :(   https://stackoverflow.com/questions/63371544/diff-color-always-no-colour-when-line-format-specified
  # My answers: https://stackoverflow.com/a/63392085/5353461   https://stackoverflow.com/a/63392564/5353461
  ignore = !"bash -c 'diff --unified=999999999 --color=always <(echo a; git check-ignore --verbose --non-matching --no-index . \"$@\") <(echo b; git check-ignore --verbose --non-matching . \"$@\")' - \"$@\" | tail -n+7; git hidden \"$@\" # Show ignore status of arguments. Files included by index are tagged with prepended '+'."
  ignore-q = !"bash -c 'diff --unified=999999999 --color=always <(echo a; git check-ignore --no-index . \"$@\") <(echo b; git check-ignore . \"$@\")' - \"$@\" | tail -n+7; git hidden \"$@\" # quieter version -- only ignored paths"
  hidden = !"git ls-files -v -- \"$@\"| grep -E '^(S|[[:lower:]])' # S means update-index --skip-worktree, and lower first letter means --assume-unchanged."
  ignored = !"{ git ls-files -oz; git ls-files -z; } | xargs -0 git ignore-q \"$@\" # Show all ignored and hidden paths. Pass -v for why."

  repo = !"bash -c 'r=$(realpath \"${@:$#}\") && cd \"$(dirname \"$r\")\" && git \"${@:1:$# -1}\" \"$r\"' _ \"$@\" # Run command in directory of realpath of last argument, convert it to realpath"
  # Top level directory of repository
  top = !"git \"$@\" #"  # re-run git command in repository toplevel directory
  root = rev-parse --show-toplevel  # Show git top-level
  # For superproject and submodules toplevel see https://stackoverflow.com/a/52047313/5353461
  git-dir = rev-parse --git-dir  # Show .git directory

  # Show changes in a file, following renames
  changes = log --follow --stat --patch

  tag-latest = !"git describe --tags $(git rev-list --tags --max-count=1) #"

  #
  # Branches / remotes
  #

  # Mine: https://stackoverflow.com/a/52906108/5353461, https://stackoverflow.com/a/52913537/5353461
  branch-current = "symbolic-ref --short HEAD"  # https://stackoverflow.com/a/19585361/5353461, at bottom.
  # branch-name: Mine: https://stackoverflow.com/a/56564366/5353461  # Given commitish, print branch head(s) or error
  branch-name = !"git for-each-ref --format=\"%(refname:short) %(objectname)\" 'refs/heads/' | sed -En 's/^(\\S+)\\s+'\"$(git rev-parse \"$1\" 2>/dev/null)\"'$/\\1/p' | grep . || { echo \"$1: not a branch-name\" >&2; false;} # Print commit's branch heads"
  branch-or-commit = !"x=$(git branch-name \"$1\"); [ -n \"$x\" -a \"$(echo -n \"$x\" | wc -l)\" -eq 0 ] ||{ x=$(git rev-parse --verify \"$1\");}; echo \"$x\"; [ -n \"$x\" ] #"
  branch-tips = !"[ -z \"$1\" ] && git branch-current 2>/dev/null || git branch --format='%(refname:short)' --contains \"${1:-HEAD}\" #"  # https://stackoverflow.com/a/19585361/5353461
  branch-tip = !"br=$(git branch-tips \"$1\") && case \"$br\" in *$'\\n'*) printf \"Multiple branches:\\n%s\" \"$br\">&2; exit 1;; esac; echo \"$br\" #"

  # Mine: https://stackoverflow.com/a/52896538/5353461
  branch-remote-fetch = !"branch=$(git branch-tip \"$1\") && git config branch.\"$branch\".remote || echo origin #"
  branch-remote-push  = !"branch=$(git branch-tip \"$1\") && git config branch.\"$branch\".pushRemote || git config remote.pushDefault || git branch-remote-fetch #"
  branch-url-fetch = !"remote=$(git branch-remote-fetch \"$1\") && git remote get-url        \"$remote\" #"  # cognizant of insteadOf
  branch-url-push  = !"remote=$(git branch-remote-push  \"$1\") && git remote get-url --push \"$remote\" #"  # cognizant of pushInsteadOf

  branch-upstream = !"br=$(git branch-tip \"$1\") && git rev-parse --abbrev-ref --symbolic-full-name \"$br\"@{u} 2>/dev/null"
  branch-push     = !"br=$(git branch-tip \"$1\") && git rev-parse --abbrev-ref --symbolic-full-name \"$br\"@{push} 2>/dev/null"

  # Pull a different branch without affecting the current one
  plbr = !"current=$(git symbolic-ref --short HEAD) && git stash save --all && git checkout \"${1:-master}\" && git pull-autostash && git checkout \"$current\" && git stash pop #"

  commit-undo = "!git reset @~ \"$(git branch-tip)\" && git commit --amend --no-edit --allow-empty #"

  # Print only the first hash encountered
  grep-1hash = !"awk 'match($0, /[a-f0-9]{7,40}/) {print substr($0, RSTART, RLENGTH); exit}' #"
  # Print the first has on each line
  grep-hashes = !"sed -rn 's/(^|.*[^a-f0-9])([a-f0-9]{7,40})($|[^a-f0-9].*)/\\2/p' #"
  # Print all hashes encountered
  grep-hashes-all = !"c=$(grep -Eo '[a-f0-9]{7,40}' \"$@\") && echo \"$c\" || echo "Hash not found" >&2 #"

  # Print line(s) like:
  # 8d048fa (HEAD -> master) local-update: add cabal and npm 30 hours ago Tom Hale
  fmt-commit-1line = !"echo '--format=\"%C(auto)%h %s %d%C(auto,yellow)[%C(auto,nobold green)%cd%C(auto)%C(auto,bold blue) %aN%C(auto,nobold yellow)]%Creset\" --date=relative' #"
  fmt-commit-1line-iso = !"echo '--format=\"%C(auto)%h %s %d%C(auto,yellow)[%C(auto,nobold green)%cd%C(auto)%C(auto,bold blue) %aN%C(auto,nobold yellow)]%Creset\" --date=iso' #"
  print-commit-1 = !"for c in \"$@\"; do c=\"$(git rpc \"$c\")\" && eval \"git log -n1 $(git fmt-commit-1line) $c\"; done #"
  # Print line(s) like:
  # 8d048fa (HEAD -> master) local-update: add cabal and npm 2016-10-03 12:29:38 +0700 Tom Hale
  print-commit-1-long = !"for c in \"$@\"; do c=\"$(git rpc \"$c\")\" && eval \"git log -n1 $(git fmt-commit-1line) --date=iso $c\"; done #"

  # Print the --decorations of `git log` without the ( ) eg "HEAD -> master, tag: head, origin/master"
  # TODO: for HEAD (or commit-ish if given)
  # With -n1, only last argument is used (strangely). Verify one argument is a commit-ish.
  decorations = !"c=\"$(git rpc \"${1:-@}\")\" && git log -n1 --format=\"%C(auto)%D\" \"$c\" #"


  #
  # Ancestors
  #

  # TODO: warn if there is more than one parent

  # Print the $1-th first-parent of commit $2, or the earliest existing commit if the beginning of history is reached
  # Defaults: $1=1 %$2=HEAD. If 0th parent is requested, the commit itself is returned. Test for -eq ensures numeric.
  parent = !"[ \"${1:-1}\" -eq \"${1:-1}\" ] && c=$(git rev-parse \"${2:-@}\") && git log -n\"$(expr \"${1:-1}\" + 1)\" --first-parent --pretty=\"%H\" --reverse \"$c\" | head -n1 #"


  #
  # Children / Descendants (scions)
  #
  # All children hashes of current (or specified) commit-ish sorted newest first
  children-hash = !"c=\"$(git rpc \"${1:-@}\")\" && set -- $(git rev-list --all --not \"$c\"^@ --children | grep \"$c\"); shift; for c in $*; do echo $c; done | tac #"
  children = !"git print-commit-1 $(git children-hash \"$1\") #"
  children-long = !"git print-commit-1-long $(git children-hash \"$1\") #"

  # Scions (definition): A descendant, especially a first-generation descendant; a shoot or twig.
  # Descendant paths from $2 path back to $1
  # Newest first is required for --graph to do it's pretty thing
  # Includes $2, excludes $1
  # Use 'HEAD' if $1 not given. Use last checked out branch if $2 not given

  # scions = !"sh -c \"git log $(git fmt-commit-1line) --graph --ancestry-path ${1:-HEAD}..${2:-\\\"$(git rev-parse @{-1})\\\"}\" -"
  # scions-long = "!git print-commit-1-long $(git scions-hash \"$1\" \"$2\") #"

  # works at command prompt:
  # set master tip
  # eval git log $(git fmt-commit-1line) --graph --ancestry-path "$(git rpc "${1:-@}")".."$(git rev-parse "${2:-"@{-1}"}")"
  # try setting from to variables then using.
  # scions = !"eval git log $(git fmt-commit-1line) --graph --ancestry-path \"$(git rpc \"${1:-@}\")\"..\"$(git rev-parse \"${2:-\"@{-1}\"}\")\" #"
  #
  scions = !"eval git log $(git fmt-commit-1line) --graph --ancestry-path \"${1:-HEAD}\"..\"${2:-$(git rev-parse @{-1})}\" #"
  scions-long = !"eval git log $(git fmt-commit-1line) --date=iso --graph --ancestry-path \"${1:-HEAD}\"..\"${2:-$(git rev-parse @{-1})}\" #"

  scions-hash = !"git log --format=%H --ancestry-path \"${1:-HEAD}\"..\"${2:-$(git rev-parse @{-1})}\" #"
  scions-list = !"git print-commit-1 $(git scions-hash \"$1\" \"$2\") #"
  scions-list-long = !"git print-commit-1-long $(git scions-hash \"$1\" \"$2\") #"

  # ---------------- Good above here -------------------- #

  # TODO ask all diff colours see note++ 11
  #
  # TODO use select with fixup
  # IFS=$'\n' && select name in $(g logda --color=always); do echo $name; break; done


  # Direct-decendant commits of $1 which are also ancestors of $2, sorted newest first
  # Use 'HEAD' if $1 not given. Use last checked out branch if $2 not given
  children-branch = !"git print-commit-1 $(git children-branch \"$1\" \"$2\") #" # Subshell unquoted to split output into arguments 
  children-branch-hash = !"c=$(git children \"$1\") && git scions \"$1\" | grep -xF \"$c\" #"

  # TODO split into a function which announces if there is more than one child and whether the oldest is a branch-child
  # The newest child commit with descendant $2, else the newest child overall
  #FIXMEEEEE IFS:
  child-hash = !"c=$(git scions-hash \"$1\" \"$2\" | tail -1) && if [ \"$c\" ]; then echo $c; else git children-branch-hash \"$1\" | tail -1 || echo no branch; fi #"
  child = !"git print-commit-1 $(git child-hash \"$1\" \"$2\") #"


  # TODO:
  # Execute a fetch on all the remotes you have configured
  # fetchall = !bash -c 'source /etc/bash_completion.d/git && __git_remotes | xargs --no-run-if-empty -t -n1 git fetch $*' -

  # Generate fixup/squash for HEAD or specified commit
  fixup  = !"git commit -m \"fixup! $(c=$1; shift; git log -1 --format='%h %s' \"$(git rpc \"$c\")\")\" \"$@\" #"

  # Automatically fix commit $1 based on index.  $2... are git commit options. # https://blog.filippo.io/git-fixup-amending-an-older-commit/
  fixup-auto = "!f() { commit=$(git rpc \"$1\") || return; shift; git commit --fixup=\"$commit\" \"$@\" && git rbia \"$commit\"; }; f"

  #
  # Boolean tests
  #

  # Return true if index AND working directory are clean
  status-clean = !"[ -z \"$(git status --porcelain)\" ] #"
  status-clean-ignore-untracked = !"[ -z \"$(git status -uno --porcelain)\" ] #"

  is-branch = !"git show-ref -q --verify refs/heads/\"$1\" #"
  is-tag    = !"git show-ref -q --verify refs/tags/\"$1\" #"
  is-remote = !"git show-ref -q --verify refs/remotes/\"$1\" #"

  # True if is a repository and is empty
  # https://stackoverflow.com/a/5492347/5353461
  is-empty-repo = !"c=$(git count-objects 2>/dev/null) && set $c x && [[ $1 -eq 0 ]]"

  # ---------------

  # TODO use -e only if no additional -m given
  squash = !"c=\"$1\"; shift; git commit -m \"squash! $(git log -1 --format='%s' \"$c\")\" \"$@\" -e #" # -e to add message to squash in

  # Run a command in the root of the working tree
  bsh     = !"\"$@\" #" # BOURNE shell, save some typing in default case :)
  sh      = !"bash -c '\"$@\"' -" # default to bash
  zsh     = !"zsh  -c '\"$@\"' -"
  sheval  = !"bash -c 'eval \"$@\"' -"
  shevalq = !"bash -c 'shell-quote eval \"$@\"' -"
  bsheval = !"sh   -c 'eval \"$@\"' -"
  zsheval = !"zsh  -c 'eval \"$@\"' -"

  # Quote / unquote a sh command, converting it to / from a git alias string
  quote-string = !"read -r l; printf !\\\"; printf %s \"$l\" | sed 's/\\([\\\"]\\)/\\\\\\1/g'; printf \" #\\\"\\n\" #"
  quote-string-undo = !"read -r l; printf %s \"$l\" | sed 's/\\\\\\([\\\"]\\)/\\1/g'; printf \"\\n\" #"

  # Show files ignored by git
  ign = ls-files -o -i --exclude-standard

  # The files changed between commit $2 and $1
  # Use HEAD if $1 not given and (first parent of $1) if $2 not given
  files = !"new=\"$(git rpc \"${1:-@}\")\" && old=\"$(git rpc \"${2:-\"$new~\"}\")\" && git diff --name-status \"$old\" \"$new\" #"

  # Create complex function then run it
  # http://blogs.atlassian.com/2014/10/advanced-git-aliases/

  # Remove local branches that have already been merged
  # Target is master unless otherwise specified
  bclean = "!git branch --merged ${1-master} | grep -v \" ${1-master}$\" | xargs -r git branch -d #"

  # Simple diff ignoring line number changes
  sortdiff = !"git diff \"$@\" | grep \"^[+-]\" | sort --key=1.2 | uniq -u -s1 #"

  # Edit this module's config file
  edit-config = !"$VISUAL $(git rev-parse --git-dir)/config #"

  # Manage this config file
  # ~/.gitconfig will be read after and override ~/.config/git/config
  edit-global-config = "![ -f ~/.gitconfig -a -f ~/.config/git/config ] && ! confirm \"Two config files exist. Edit ~/.gitconfig?\" && exit || git config -e --global #"
  backup-config = "!c=~/.config/git/config;g=~/.gitconfig; [ -e \"$g\" -a x$1 != x-f ] && echo \"$g exists. Not modified\" || cp -vp \"$c\" \"$g\" #"
  rmbackup-config = "!rm -v ~/.gitconfig"

  # Edit excludes files
  edit-global-excludes = !"bash -c 'f=$(git config core.excludesFile); \"$VISUAL\" \"${f/#\\~/$HOME}\"' #"
  edit-local-excludes = !"\"$VISUAL\" \"$(git rev-parse --show-toplevel)/.gitignore\" #"

[branch]
  # tell git-branch and git-checkout to setup new branches so that git-pull(1)
  # will appropriately merge from that remote branch.  Recommended.  Without this,
  # you will have to add --track to your branch command or manually merge remote
  # tracking branches with "fetch" and then "merge".
  autosetupmerge = true

[color]
# Colours: black, red, green, yellow, blue, magenta, cyan, white, reset
# After the foreground color, you can optionally list a background color
# Modifiers: bold dim italic ul blink reverse strike.
# Also: 24-bit colours: #ff69b4; Disable modifier: no-<modifier>
# Get complete list of variables: https://stackoverflow.com/q/47176670/5353461
# http://shallowsky.com/blog/programming/gitcolors.html
  ui = auto
  [color "branch"]
    current = yellow reverse
    local = yellow
    remote = green
    upstream = cyan
    plain = white
  [color "decorate"]
    branch = bold green
    HEAD = red
    remoteBranch = bold cyan
    # stash =
    # tag =
  [color "diff"]
    commit = bold yellow
    context = normal
    frag = bold yellow
    func = white bold
    meta = yellow bold
    new = green bold
    old = red bold
    whitespace = red reverse
    # Zebra pair #1
    oldMoved = blue dim strike
    newMovedAlternative = blue italic
    # Zebra pair #2
    newMoved = cyan dim strike
    oldMovedAlternative = cyan strike
    # Dimmed pair #1
    oldMovedDimmed = dim blue strike
    newMovedAlternativeDimmed = blue italic
    # Dimmed pair #2
    oldMovedAlternativeDimmed = dim cyan strike
    newMovedDimmed = cyan italic
  [color "diff-highlight"]
    oldNormal = red bold
    oldHighlight = red bold 52
    newNormal = green bold
    newHighlight = green bold 22
  [color "grep"]
    context = normal
    filename = normal
    function = normal
    linenumber= normal
    match = yellow bold
    matchContext = normal
    matchSelected = normal
    selected = normal
    separator = normal
  [color "interactive"]
    prompt = yellow bold
    header = magenta
    help = white bold
    error = red bold
  [color "status"]
    added = yellow
    changed = red
    header = normal
    nobranch = red bold
    untracked = cyan
    updated = green

[commit]
  verbose = true # include diff output for easy review

[delta]
    features = line-numbers decorations
    inspect-raw-lines = true  # default: true which support git's --color-moved
    plus-color = "#012800"
    minus-color = "#340001"
    # plus-style = syntax "#003800"
    plus-style = syntax bold auto
    # minus-style = syntax "#3f0001"
    minus-style = syntax bold auto
    syntax-theme = Monokai Extended
    whitespace-error-style = 22 reverse

[delta "decorations"]
    commit-decoration-style = bold yellow box
    file-style = bold yellow ul
    file-decoration-style = none

[diff]
  # https://git-scm.com/docs/git-diff
  algorithm = patience # Take longer for a smaller diff
  # colorMoved = zebra
  colorMoved = dimmed_zebra
  indentHeuristic = true # New default from v2.14, see https://github.com/blog/2188-git-2-9-has-been-released
  interHunkContext = 2
  renames = copies  # detect both copies and renames
  tool = vimdiff
  wsErrorHighlight = old,new

  # https://git-scm.com/docs/gitattributes
  # Remove cachetextconv via : git update-ref -d refs/notes/textconv/<driver>
  [diff "strings"]
    # `strings -a` may cause null output - git won't print a header in that case
    textconv=strings -a
  [diff "hexdump"]
    textconv=hexdump -vC
  [diff "pdf"]
    textconv="pdfinfo \"$1\"; pdftotext \"$1\" - #"
  [diff "zip"]
    textconv=unzip -v
    cachetextconv = true
  [diff "exif"]
    textconv = exiftool # Many file formats. https://en.wikipedia.org/wiki/ExifTool
    cachetextconv = true
  [diff "ps"]
    textconv = ps2ascii
    binary=true # Mark as a binary even though they are meaningless text
  [diff "jupyternotebook"]
    command = git-nbdiffdriver diff

[difftool]
  prompt = true # Use alias for no-prompt
  trustExitCode = true # true by default, :cq in vim to exit non-zero
  [difftool "nbdime"]
    cmd = git-nbdifftool diff \"$LOCAL\" \"$REMOTE\" \"$BASE\"

[interactive]
  # diff-so-fancy doesn't work with --patch because it produces 4- rather than the expecte 5-line headers:
  # https://github.com/so-fancy/diff-so-fancy/issues/35
  # https://github.com/so-fancy/diff-so-fancy/pull/172
  # https://github.com/so-fancy/diff-so-fancy/issues/296
  # diffFilter = "diff-so-fancy"

  # diffFilter filters output for later paging, so don't pass through a pager.
  # The default (or when set to 'cat') seems to be "diff-highlight"
  diffFilter = "{ command -v diff-hi &>/dev/null && diff-hi || cat; }"  # Braces keep STDIN consistent

  # Remove the need to press enter after an interactive prompt.
  # Required packages: Arch: perl-term-readkey, Ubuntu: libterm-readkey-perl
  singleKey = true

[log]
  mailmap = true

[merge]
  conflictStyle = diff3 # include original lines
  tool = vimdiff
  stat = true # show what changed
  [merge "jupyternotebook"]
    driver = git-nbmergedriver merge %O %A %B %L %P
    name = jupyter notebook merge driver

[mergetool]
  prompt = true # Use alias for no-prompt
  [mergetool "nbdime"]
    cmd = git-nbmergetool merge \"$BASE\" \"$LOCAL\" \"$REMOTE\" \"$MERGED\"

[mergetool "vimdiff"]
  trustExitCode = true # true by default, :cq in vim to exit non-zero

[pager]
  # Bypass pager: git --no-pager ...
  # "X = true" means use pager defined in [core]
  # add      = /usr/bin/less -FLRX --tabs=4
  # add      = true # disabled currently due to bug - doesn't prompt with git add --patch # TODO raise issue
  # diff     = "diff-hi | less -FLRX --tabs=4"
  # diff     = "diff-so-fancy | less -FLRX --tabs=4"
  diff     = true
  difftool = true
  log      = true
  show     = true
  # Consider https://github.com/so-fancy/diff-so-fancy - removes +/- leaders
  # but ugly when less than one screen's worth of output - blank lines are all '~'

  # Allow hunk movement with n/p keys
  # diff = diff-hi | less -FLRX --tabs=4 --pattern '^(\\@\\@.*,.*,.*\\@\\@|diff --git .* .*)$' # Allow hunk movement with n/p keys

[pretty]
  reflog = %C(auto)%h %>|(18)%gd %C(blue)%ci%C(reset) %s  # Make HEAD{N} end at col 18, left pad.

[pull]
  rebase = merges  # pass --rebase-merges . The deprecated =preserve passes --preserve-merges to rebase so locally committed merges aren't flattened
  autostash = false  # See script: git-pull-autostash

[push]
  default = simple

[rebase]
  autosquash = true
  autostash = true
  missingCommitsCheck = error  # Protect against accidentally removed lines
  stat = true  # Show what changed

[rerere] # .git/rr-cache
  enabled = true
  autoupdate = true  # Auto-stage resolved conflicts

[submodule]
  fetchJobs = 5  # Fetch max submodules fetched/cloned at the same time

[status]
  submoduleSummary = true
  showStash = true

[tag]
  sort = -version:refname  # Reverse sort versions numerically. See also [versionsort]

[url "ssh://aur@aur.archlinux.org"]
  pushInsteadOf = "https://aur.archlinux.org"

[url "ssh://git@github.com"]
  pushInsteadOf = "https://github.com"

[versionsort]
  # prereleaseSuffix is deprecated in favour of suffix, but used for compatibility.
  # https://git-scm.com/docs/git-config#git-config-versionsortprereleaseSuffixdeprecated
  prereleaseSuffix = "-"  # Have 2.0-rc1 be earlier than 2.0
