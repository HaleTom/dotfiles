[include]
  # Put personal details (eg name, email) in another file
  # This file is excluded by .gitignore
  path = ~/.gitconfig.local

[core]
  editor = vim
  pager = less -FRX --tabs=4
  excludesfile = /home/ravi/.gitignore_global

  # convert newlines to system's standard on checkout,
  # and to LF when checking in
  # Eeek - causes addition of CR in linux
  # autocrlf = true

# Alias syntax learnings:
# Double quotes around shell commands are not required
# If you want to \ continue a line, it must be inside a "-quoted string
# Continue/wrap long lines with final \ character
# It's not possible to have a comment after a continuation \
# Quote ALL " and \ characters as \" and \\
# A literal '#' or ';' must be inside "-quotes
; this is also a comment
[alias]
  a      = add
  aa     = add -A
  aacm   = "!f() { git add -A && git commit -m \"$@\"; }; f"
  ai     = add --intent-to-add
  ap     = add --patch
  au     = "!git ls-files -z -o --exclude-standard | xargs -0 git add; #" # Add only untracked files
  aw     = !git diff -U0 -w --no-color -- \"$@\" | git apply --cached --ignore-whitespace --unidiff-zero "#" # Add only non-whitespace changes
  aow    = !git add -- \"$@\" && git diff --cached -w | git apply --cached -R "#" # Add only whitespace changes
  bash   = !bash -c '\"$@\"' - # Run command in working tree's root
  br     = branch
  c      = commit
  co     = checkout
  cob    = checkout -b
  # Create a branch tracking the same branch on origin.
  # '-' makes argument list start at $1
  cobt   = !sh -c 'git checkout -b "$1" && git branch --track origin/"$1"' -
  # Pick chunks to include of changed files, include all untracked files.
  ca     = commit -a -v
  caa    = "!f() { git add -A && git commit \"$@\"; }; f"
  caam   = "!f() { git add -A && git commit --message \"$@\"; }; f"
  caan   = "!f() { git add -A && git commit --amend "\"$@\"; }; f"
  caanm   = "!f() { git add -A && git commit --amend -m "\"$@\"; }; f"
  caann  = "!f() { git add -A && git commit --amend --no-edit; }; f"
  cam    = commit -am  # note only changed files included
  can    = commit -a --amend
  cann   = commit -a --amend --no-edit
  canm   = commit -a --amend -m
  cl     = clone
  clear  = "!bash -c ' git clean -n | sed \"s/^Would remove //\"; \
    read -rn1 -p \"Delete all the above? [y/N] \" r; echo; \
    [[ x$r =~ ^x[yY] ]] && git clean -f || echo Untouched.'"
  cm     = commit -m
  cn     = commit --amend
  cnc    = commit --amend -C HEAD
  cnm    = commit --amend -m
  cp     = commit --patch
  cvp    = "!f() { git commit -v --patch \"$@\"; git st; }; f"
  # Select hunks from tracked files, then commit with all untracked files before commit
  cvpn   = "!f() { git commit -v --patch && \
    git ls-files -z -o --exclude-standard | xargs -0 git add && \
    echo '# Add only new files silently' > /dev/null && \
    git commit -a --amend --no-edit && \
    git status -s; }; f"
  db     = !GIT_TRACE=1 git # Use to debug an alias, Eg: git db <aliasname>
  debug  = "!set -x; GIT_TRACE=2 GIT_CURL_VERBOSE=2 GIT_TRACE_PERFORMANCE=2 GIT_TRACE_PACK_ACCESS=2 GIT_TRACE_PACKET=2 GIT_TRACE_PACKFILE=2 GIT_TRACE_SETUP=2 GIT_TRACE_SHALLOW=2 git \"$@\" #"
  dc     = diff --cached --ws-error-highlight=all
  dcw    = diff --cached --color-words --ws-error-highlight=all
  df     = diff --ws-error-highlight=all # old,new,context,all
  dfw    = diff --color-words --ws-error-highlight=all # old,new,context,all
  dh     = diff HEAD
  dhh    = diff HEAD~1
  ds     = diff --stat
  dt     = difftool -y -t vimdiff --noprompt
  icdiff = difftool --no-prompt --extcmd icdiff # \"$@\"
  logd   = log --oneline --graph --decorate --remotes --max-count=20
  logda  = log --oneline --graph --decorate --remotes --all --max-count=20
  logdaa = log --oneline --graph --decorate --remotes --all
  ls     = ls-files
  mum    = merge upstream/master
  psfwl  = push --force-with-lease
  psuo   = push --set-upstream origin
  psuob  = push --set-upstream origin `git rev-parse --abbrev-ref HEAD`
  pl     = pull
  ps     = push
  pum    = pull upstream master
  rb     = rebase
  rba    = rebase --abort
  rbb    = !sh -c \"git rebase -i `git merge-base $1 HEAD` #\" # Rebase to branch-name # http://stackoverflow.com/a/31036518/5353461
  rbc    = rebase --continue
  rbi    = rebase -i HEAD~20
  re     = reset
  res    = reset --soft
  reh    = reset HEAD
  rehh   = reset --hard HEAD
  rl     = reflog
  rmc    = rm --cached
  s      = status --short #--branch
  sm     = submodule
  sa     = stash apply
  sl     = stash list
  ss     = stash save
  st     = !git s # motor memory trainer wheels
  sp     = stash pop

  # Run a command in the root of the working tree
  sh = !bash -c '\"$@\"' - # default to bash
  bsh = !\"$@\" - # Bourne shell

  # list aliases
  la = !git config --list | grep ^alias\\. | cut -c 7- | grep -Ei --color \"$1\" "#"

  # Show files ignored by git
  ign = ls-files -o -i --exclude-standard

  # Show files changed between the given commit and it's previous commit
  files = !sh -c 'git diff --name-status "$1"^ "$1"' -
  
  # Create complex function then run it
  # http://blogs.atlassian.com/2014/10/advanced-git-aliases/

  # Remove local branches that have already been merged
  # Target is master unless otherwise specified
  bclean = "!f() { git branch --merged ${1-master} | grep -v " ${1-master}$" | xargs -r git branch -d; }; f"

  # Simple diff ignoring line number changes
  sortdiff = !sh -c 'git diff "$@" | grep "^[+-]" | sort --key=1.2 | uniq -u -s1'
  
  editglobalconfig = "config -e --global"
  
[push]
  default = simple

[branch]
  # tell git-branch and git-checkout to setup new branches so that git-pull(1)
  # will appropriately merge from that remote branch.  Recommended.  Without this,
  # you will have to add --track to your branch command or manually merge remote
  # tracking branches with "fetch" and then "merge".
  autosetupmerge = true
  
[color]
  ui = auto
  [color "branch"]
    current = yellow reverse
    local = yellow
    remote = green
  [color "diff"]
    meta = yellow bold
    frag = magenta bold
    old = red bold
    new = green bold
    whitespace = red reverse
  [color "diff-highlight"]
    oldNormal = red bold
    oldHighlight = red bold 52
    newNormal = green bold
    newHighlight = green bold 22
  [color "status"]
    added = yellow
    changed = green
    untracked = cyan
[commit]
  verbose = true # include diff output
[diff]
  tool = vimdiff
[difftool]
  prompt = false
[merge]
  tool = vimdiff
[pager]
  # Bypass pager: git --no-pager ...
  # Consider https://github.com/so-fancy/diff-so-fancy - removes +/- leaders
  log = diff-hi | less
  show = diff-hi | less
  diff = diff-hi | less -FRX --tabs=4
  difftool = true # Use pager defined in [core]
  
  # Allow hunk movement with n/p keys
  # but ugly when less than one screen's worth of output - blank lines are all '~'
  # diff = diff-hi | less -FRX --tabs=4 --pattern '^(\\@\\@.*,.*,.*\\@\\@|diff --git .* .*)$' # Allow hunk movement with n/p keys
